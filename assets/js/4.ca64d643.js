(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{207:function(t,e,a){t.exports=a.p+"assets/img/newVueFlow.fbedb6a5.jpg"},208:function(t,e,a){t.exports=a.p+"assets/img/vueRender.e17706df.jpg"},209:function(t,e,a){t.exports=a.p+"assets/img/new-vue.9f257f78.png"},210:function(t,e,a){t.exports=a.p+"assets/img/lifecycle.10067f20.jpg"},233:function(t,e,a){"use strict";a.r(e);var r=a(0),s=Object(r.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"vue-源码解读"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码解读","aria-hidden":"true"}},[t._v("#")]),t._v(" vue 源码解读")]),t._v(" "),r("h2",{attrs:{id:"flow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flow","aria-hidden":"true"}},[t._v("#")]),t._v(" flow")]),t._v(" "),r("p",[t._v("静态类型检查，通过类型推断和类型注释检查类型")]),t._v(" "),r("p",[t._v("在 vue 源码的 flow 目录中定义了 vue 中用到的自定义类型")]),t._v(" "),r("h2",{attrs:{id:"目录结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录结构","aria-hidden":"true"}},[t._v("#")]),t._v(" 目录结构")]),t._v(" "),r("p",[t._v("在 vue 的源码中，作者将功能模块拆分的非常的细，相关的逻辑放在一个单独的目录中维护，将复用的逻辑也抽成一个单独的目录。")]),t._v(" "),r("h2",{attrs:{id:"构建"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建","aria-hidden":"true"}},[t._v("#")]),t._v(" 构建")]),t._v(" "),r("p",[t._v("使用 rollup 构建，rollup 只处理 js 代码，它比 webpack 更轻量")]),t._v(" "),r("h3",{attrs:{id:"runtime-only-vs-runtime-compiler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runtime-only-vs-runtime-compiler","aria-hidden":"true"}},[t._v("#")]),t._v(" runtime-only vs runtime+compiler")]),t._v(" "),r("p",[t._v("runtime-only 版本的 vue,会在 webpack 打包的过程中将 .vue 文件编译成 js 代码。这样打包出的项目代码会小很多并且性能也更好。")]),t._v(" "),r("p",[t._v("runtime+compiler 版本的 vue,是在项目运行的时候去编译 vue 的 template 编译成 render. 项目代码更多并且性能更差。在定义 vue 组件时使用的 template 属性就要使用 runtime+compiler 版本")]),t._v(" "),r("h2",{attrs:{id:"在引入-vue-时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在引入-vue-时","aria-hidden":"true"}},[t._v("#")]),t._v(" 在引入 Vue 时")]),t._v(" "),r("p",[t._v("在引入 Vue 时(即 import vue form Vue)，就会在 vue 原型和 vue 构造函数上挂载一些方法")]),t._v(" "),r("h2",{attrs:{id:"new-vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new-vue","aria-hidden":"true"}},[t._v("#")]),t._v(" new Vue")]),t._v(" "),r("p",[t._v("在 new Vue 时会设置 vue 实例的父子关系，给 data, props, methods 设置代理，初始化 injections,初始化 provide等")]),t._v(" "),r("h2",{attrs:{id:"vue-实例创建与挂载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-实例创建与挂载","aria-hidden":"true"}},[t._v("#")]),t._v(" Vue 实例创建与挂载")]),t._v(" "),r("p",[r("img",{attrs:{src:a(207),alt:"runtime + compiler版本 vue 实例挂载流程图"}})]),t._v(" "),r("h2",{attrs:{id:"render-方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render-方法","aria-hidden":"true"}},[t._v("#")]),t._v(" render 方法")]),t._v(" "),r("p",[t._v("将 $createElement 作为 render 的第一个参数，调用 $createElement 返回一个 vnode")]),t._v(" "),r("h3",{attrs:{id:"传给-render-的第一个参数是字符串"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#传给-render-的第一个参数是字符串","aria-hidden":"true"}},[t._v("#")]),t._v(" 传给 render 的第一个参数是字符串")]),t._v(" "),r("p",[t._v("例如：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("render('div',...)\n")])])]),r("p",[t._v("调用 new VNode 创建 vnode")]),t._v(" "),r("h3",{attrs:{id:"传给-render-的第一个参数是组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#传给-render-的第一个参数是组件","aria-hidden":"true"}},[t._v("#")]),t._v(" 传给 render 的第一个参数是组件")]),t._v(" "),r("p",[t._v("例如：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("render(APP)\n")])])]),r("p",[t._v("给组件添加上 Vue 的方法，例如：extend,mixin,use,component 等， 让组件的原型指向 Vue 的原型，将组件的 options 与 Vue 的 options 合并，设置 hooks，最后返回 vnode")]),t._v(" "),r("p",[r("img",{attrs:{src:a(208),alt:"render 过程"}})]),t._v(" "),r("h2",{attrs:{id:"update"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#update","aria-hidden":"true"}},[t._v("#")]),t._v(" _update")]),t._v(" "),r("p",[t._v("在初始化渲染和数据更新都会调用_update,在 _update 中会调用 patch")]),t._v(" "),r("h2",{attrs:{id:"patch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#patch","aria-hidden":"true"}},[t._v("#")]),t._v(" patch")]),t._v(" "),r("p",[t._v("在初始化渲染时调用 patch 方法的作用是创建 DOM 节点，并且将子节点插入到父节点中，最后再将生成的 DOM 树插入到 body 中。")]),t._v(" "),r("p",[t._v("组件创建是一个深度遍历")]),t._v(" "),r("h2",{attrs:{id:"new-vue-的过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new-vue-的过程","aria-hidden":"true"}},[t._v("#")]),t._v(" new Vue 的过程")]),t._v(" "),r("p",[r("img",{attrs:{src:a(209),alt:"new Vue 流程"}})]),t._v(" "),r("h2",{attrs:{id:"合并配置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合并配置","aria-hidden":"true"}},[t._v("#")]),t._v(" 合并配置")]),t._v(" "),r("p",[t._v("合并配置发生在两个时候，一个时候是 new Vue 时，另一个时候是在 render 创建组件的过程中")]),t._v(" "),r("h3",{attrs:{id:"new-vue-时合并配置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new-vue-时合并配置","aria-hidden":"true"}},[t._v("#")]),t._v(" new Vue 时合并配置")]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[t._v("vm"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$options "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("mergeOptions")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolveConstructorOptions")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        options "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        vm\n      "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),r("p",[t._v("会将 vm.constructor 上的配置合并到 vm,所以在 vm 上能够访问到 vm.constructor 上的 filter, directive 等")]),t._v(" "),r("h3",{attrs:{id:"创建组件时合并配置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建组件时合并配置","aria-hidden":"true"}},[t._v("#")]),t._v(" 创建组件时合并配置")]),t._v(" "),r("p",[t._v("由于组件的构造函数是通过 Vue.extend 继承自 Vue 的，在组件的构造函数中会将 Vue 上的配置与组件的配置进行合并，所以在组件上可以访问到 Vue 上的配置")]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("initInternalComponent")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),r("h2",{attrs:{id:"生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),r("p",[r("img",{attrs:{src:a(210),alt:"生命周期流程图"}})]),t._v(" "),r("h2",{attrs:{id:"组件的注册"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件的注册","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件的注册")]),t._v(" "),r("p",[t._v("全局注册的组件会被注册到 Vue.options.components 上")]),t._v(" "),r("p",[t._v("局部注册的组件会被注册到这个组件的 options.components 上(即：vm.options.components)，并且会将全局注册的组件合并到 vm.options.components，所以可以在任何一个组件中访问到全局注册的组件")])])},[],!1,null,null,null);e.default=s.exports}}]);