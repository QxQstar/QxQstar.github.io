(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{201:function(e,o,t){"use strict";t.r(o);var n=t(0),s=Object(n.a)({},function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"cookie，session和token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie，session和token","aria-hidden":"true"}},[e._v("#")]),e._v(" cookie，session和token")]),e._v(" "),t("h2",{attrs:{id:"cookie"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie","aria-hidden":"true"}},[e._v("#")]),e._v(" cookie")]),e._v(" "),t("p",[e._v("cookie是一种很具体的东西，指的是浏览器中能存储的一种数据，仅仅是浏览器实现的一种存储功能。cookie由服务器产生，发送给浏览器，浏览器把cookie以key-value的形式保证在某个目录下的文件文本内，下一次向cookie的有效域和路径发请求时会将cookie发送到服务器。每一个域能够存储的cookie是有限的。")]),e._v(" "),t("h2",{attrs:{id:"session"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#session","aria-hidden":"true"}},[e._v("#")]),e._v(" session")]),e._v(" "),t("p",[e._v('服务器给每个客户端分配一个"身份标识"(即：SessionID)，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了，至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。"身份标识"对应的状态存在Server端，靠一个SessionID来辨识，这个状态可以存成档案，可以存在內存里，也可以存在数据库，这种用户信息存储方式相对cookie来说更安全。客户端只需要保存自己的SessionID，而服务器要保存所有的SessionID ！如果访问服务器多了， 就得有成千上万，甚至几十万个，这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 在集群中，会需要将状态复制多份。')]),e._v(" "),t("h2",{attrs:{id:"token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#token","aria-hidden":"true"}},[e._v("#")]),e._v(" token")]),e._v(" "),t("p",[e._v("基于token的验证过程")]),e._v(" "),t("ol",[t("li",[e._v("用户登录校验，校验成功后就返回Token给客户端。")]),e._v(" "),t("li",[e._v("客户端存储token")]),e._v(" "),t("li",[e._v("客户端每次访问API时都携带token到服务器")]),e._v(" "),t("li",[e._v("服务器校验token，校验成功就返回数据")])]),e._v(" "),t("h3",{attrs:{id:"token的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#token的优势","aria-hidden":"true"}},[e._v("#")]),e._v(" token的优势")]),e._v(" "),t("ol",[t("li",[e._v("无状态，可扩展\ntoken由服务器生成，然后发送到客户端由客户端存储，服务器不存储token。负载均衡器能够将token从一个服务器传到其他服务器上。")]),e._v(" "),t("li",[e._v("安全性\n虽然token存储在客户端，但是密钥存储在服务器。token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。")]),e._v(" "),t("li",[e._v("可扩展性\n使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。")]),e._v(" "),t("li",[e._v("多平台跨域")])])])},[],!1,null,null,null);o.default=s.exports}}]);